EAdd. Exp ::= Exp "+" Exp1;
EAssign. Exp ::= Exp1;
EMult. Exp1 ::= Exp1 "*" Exp2;
EExp. Exp1 ::= Exp2;

ENum. Exp2 ::= Integer; --String, 
EString. Exp3 ::= String; --String, 

EArgs. Argss ::= String;
DArgs. Args ::= "(" [Args] ")" "{";
Dfun. Def ::= Type Ident [Args] ;
PProg. Program ::= [Def];
separator nonempty Def "";
separator nonempty Args ";";

TInt. Type ::= "void";
TChar. Type ::= "char";
TString. Type ::= "string";

separator Arg ",";
ADecl.      Arg ::= Type Ident;
SDecl.      Stm ::= Type Ident "=" Exp ";";
SWhile.     Stm ::= "while" "(" Exp ")" "{" Stm "}";
SFor.       Stm ::= "for" "(" Exp ")" "{" Stm "}";
SMay.       Stm ::= Exp2 "<" Exp2;
SMen.       Stm ::= Exp2 ">" Exp2;
SMayIgual.  Stm ::= Exp2 "<=" Exp2;
SMenIgual.  Stm ::= Exp2 ">=" Exp2;
SIgual.     Stm ::= Exp2 "==" Exp2;

SBloc.      Stm ::= [Stm] ;                   --??
SBloc.      Stm ::= "{" [Stm] "}";
SIfStm.     Stm ::= "if" "(" Exp ")" Stm;
SIfStm.     Stm ::= "if" "(" Exp ")" Stm;              --seria solo una unica sentencia, no quiero una stm
SIfElse.    Stm ::= "if" "(" Exp ")" Stm "else" Stm; 

--============ ASIGNACIONES ================> x := x + 1.
SAsignacion.     Stm ::= Type Exp3 "=" " "; 
SAsignVacio.     Stm ::= Type Exp3 "=" ""; 
separator Stm "";
 
DeclaracionConstante. DeclConst ::= Ident  "=" Lit;
SConst. Ident ::= "const" [ DeclConst ];  --identificador 
terminator DeclConst ";";
 
DeclaracionType. Type ::= Type "=" Type ";";
--SType. Type ::= "type" [ ];

--============ INSTRUCTIONS =================> program ...; ... begin ... <instruccion>; <instruccion>; <instruccion> ... end.
SBegin. Stm ::= "begin " [Instruction] "end.";
separator nonempty Stm ";";
SIntrucction. Instruction ::= [Type];
separator nonempty  Instruction ";";

TInt. Type ::= "void";
TChar. Type ::= "char";
TString. Type ::= "string";


--============ TYPE ENUM =====================> (lunes, martes, miercoles, jueves, viernes)
SIdentEnum. IdentEnum::= String "," ;
SFinalIdentEnum. IdentEnum::= String ")";
SEnum. Type ::= "(" [Ident];
separator nonempty  Type ";";


--============ TYPE SUBRANGOS ================> 1..100 o lunes..miercoles
SSubrangInt. Type ::= Integer ".." Integer ";";
SSubrangString. Type ::= String ".." String ";";


--============ PUNTEROS  ================> ^nodolista
SPuntero. Type ::= "^" Ident; --???????


--============ ARREGLOS  ================> array[1..50] of integer
SArrayReal. Stm 	::= "array[" Integer ".." Integer "] of real;"; --???????
SArrayString. Stm 	::= "array[" Integer ".." Integer "] of String;"; --???????
SArrayInteger. Stm 	::= "array[" Integer ".." Integer "] of Integer;"; --???????
SArrayBoolean. Stm 	::= "array[" Integer ".." Integer "] of Boolean;"; --???????



--============ REGISTROS  ================> 
--record
--x, y, z : real;
--i : integer;
--order : (lt, gt, eq)
--end

SVariableDeRegistroInteger. Reg ::= [Stm] ":" Exp2;   --puse STM pero esta mal. solo para q compile
SVariableDeRegistroString. Reg ::= [Stm] ":" Exp3;  
SRegistro. Registro ::= "record" [Reg] "end;";
terminator Reg ";";

--============ IDENTIFICADORES  ================> boolean, char, integer, real
SIdentBoolean. Type ::= String;
SIdentChar. Type ::= Char;
SIdentInteger. Type ::= Integer;
--SReal. Type ::= Real;


--============ FUNCTIONS  ================> function suma (a, b : integer; var z : real) : integer;

SFunction. Function ::= "function" String "(" [Stm] ")" ":" Type;

